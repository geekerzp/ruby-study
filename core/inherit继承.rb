# 继承的root
# ~~~~~~~~~~
# 继承的根root为BasicObject
# BasicObject的直接子类为Object
# 所有其他类都继承Object 
#
#
# 链式调用来扩展方法的功能
# ~~~~~~~~~~~~~~~~~~~~~~~~
# 增加一些代码对方法的行为进行扩展称为"链式调用"，使用关键字super
# 当使用不带任何参数super时，向超类方法传递的参数时当前方法的所有参数
# 当传递部分参数或不传递任何参数时，要显式使用括号
#
# Define a Point3D class inherited from Point class 
# The Point class is in the file class_definition
class Point3D < Point 
  def initialize(x,y,z)
    super(x,y)
    @z = z
  end 
end
#
#
# 类方法的继承
# ~~~~~~~~~~~~
# 在指名接收者的情况下调用类方法时，要尽量避免依赖继承，
# 应该总是通过定义时所在的类来调用类方法。
# 在类方法或类的定义中，可以不指名接收者就调用其他类方法，在这种情况下，它的接收者隐式的指向self，
# 在类方法或类定义体中，self的值就是它所在的类。
#
#
# 实例变量的继承
# ~~~~~~~~~~~~~~
# Ruby的实例变量不会被继承，它们与继承机制毫无关系。
# 有时它们看起来好像被继承的原因是，方法在第一次赋值时创建它们，而这些方法通常是继承而来并进行了链式调用。
#
#
# 类变量的继承
# ~~~~~~~~~~~~
# 如果子类为一个已经在超类中使用的类变量赋值，它不会创建这个类变量的私有拷贝，而是直接修改父类中看到的那个变量，
# 同时其他的子类也会看到这个被修改的值。
# 如果一个类使用了类变量，它的所有子类和后代类都可以通过修改这个变量来改变这个类的行为。
